
namespace Utility;
internal static partial class VEC_Generate {
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  These are not CoordinateSystem agnostic.
    //
    //               +Y
    //              |
    //              |      Far                   Plane Z     Plane Y     Plane X
    //              |    +Z                      Spans XY    Spans XZ    Spans ZY
    //              |   /                        +Y          +Z          +Y
    //              |  /                        |           |           |
    //              | /                         |           |           |
    //              |/           +X             |      +X   |      +X   |      +Z
    //              +------------               +------     +------     +------
    //          Near
    //
    //  The starting orientations are selected for being practical, not "correct".
    //
    //  Theta in Radians.  +Theta is Clockwise, from perspective of +Axis looking towards Zero.
    //
    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Vector2  FROM  Angle (in radians).
    //
    //      (-360) == ( 0, 1)
    //      (-270) == ( 1, 0)
    //      (-180) == ( 0,-1)
    //      (- 90) == (-1, 0)
    //      (   0) == ( 0, 1)
    //      (  90) == ( 1, 0)
    //      ( 180) == ( 0,-1)
    //      ( 270) == (-1, 0)
    //      ( 360) == ( 0, 1)
    //
    [Impl(AggressiveInlining)] internal static vec2 FromAng(float Theta) => new vec2(sin(Theta), cos(Theta));

    //==========================================================================================================================================================
    //
    //  Vector3  FROM  Angle (in radians).
    //
    //           From-Pitch                  From-Yaw                    From-Roll
    //      (-360) == ( 0, 0, 1)        (-360) == ( 0, 0, 1)        (-360) == ( 0, 1, 0)
    //      (-270) == ( 0,-1, 0)        (-270) == ( 1, 0, 0)        (-270) == (-1, 0, 0)
    //      (-180) == ( 0, 0,-1)        (-180) == ( 0, 0,-1)        (-180) == ( 0,-1, 0)
    //      (- 90) == ( 0, 1, 0)        (- 90) == (-1, 0, 0)        (- 90) == ( 1, 0, 0)
    //      (   0) == ( 0, 0, 1)        (   0) == ( 0, 0, 1)        (   0) == ( 0, 1, 0)
    //      (  90) == ( 0,-1, 0)        (  90) == ( 1, 0, 0)        (  90) == (-1, 0, 0)
    //      ( 180) == ( 0, 0,-1)        ( 180) == ( 0, 0,-1)        ( 180) == ( 0,-1, 0)
    //      ( 270) == ( 0, 1, 0)        ( 270) == (-1, 0, 0)        ( 270) == ( 1, 0, 0)
    //      ( 360) == ( 0, 0, 1)        ( 360) == ( 0, 0, 1)        ( 360) == ( 0, 1, 0)
    //
    //         Result on plane          Result on plane             Result on plane
    //         spanning ZY.             spanning XZ.                spanning XY.
    //
    [Impl(AggressiveInlining)] internal static vec3 FromPch(float Theta) => new vec3(         0f, -sin(Theta), cos(Theta));
    [Impl(AggressiveInlining)] internal static vec3 FromYaw(float Theta) => new vec3( sin(Theta),          0f, cos(Theta));
    [Impl(AggressiveInlining)] internal static vec3 FromRol(float Theta) => new vec3(-sin(Theta),  cos(Theta),         0f);

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Vector3  FROM  (Pitch, Yaw)
    //
    //      ( -90,   0) == ( 0, 1, 0)
    //      (   0,   0) == ( 0, 0, 1)
    //      (  90,   0) == ( 0,-1, 0)
    //
    //      (   0,-360) == ( 0, 0, 1)
    //      (   0,-270) == ( 1, 0, 0)
    //      (   0,-180) == ( 0, 0,-1)
    //      (   0, -90) == (-1, 0, 0)
    //      (   0,   0) == ( 0, 0, 1)
    //      (   0,  90) == ( 1, 0, 0)
    //      (   0, 180) == ( 0, 0,-1)
    //      (   0, 270) == (-1, 0, 0)
    //      (   0, 360) == ( 0, 0, 1)
    //
    [Impl(AggressiveInlining)]
    internal static vec3 FromPchYaw(float Pch, float Yaw) {
        float CosPch = cos(Pch);

        return new vec3(
              CosPch * sin(Yaw),
            -sin(Pch),
              CosPch * cos(Yaw)
        );
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
    //
    //  Rotation(Pitch, Yaw, 0)    FROM    DirectionNormalized(X, Y, Z)
    //
    //      ( 0, 0, 1) == (  0,  0, 0)
    //      ( 0,-1, 0) == ( 90,  0, 0)
    //      ( 0, 0,-1) == (  0,180, 0)
    //      ( 0, 1, 0) == (-90,  0, 0)
    //
    //      ( 0, 0, 1) == (  0,  0, 0)
    //      ( 1, 0, 0) == (  0, 90, 0)
    //      ( 0, 0,-1) == (  0,180, 0)
    //      (-1, 0, 0) == (  0,-90, 0)
    //
    [Impl(AggressiveInlining)]
    internal static vec3 RotFromVec(vec3 V) {
        float Pch, Yaw;

        //V.z = -V.z;
        Pch = atan2(-V.y, sqrt(V.x*V.x + V.z*V.z));

        if (abs(Pch) >= (PIH-EPSILON)) {
            Pch = sign(PIH, Pch);
            Yaw = 0f;
        } else {
            Yaw = wrap(atan2(V.x, V.z), -PI, PI);
        }

        return new vec3(Pch, Yaw, 0f);
    }

    //##########################################################################################################################################################
    //##########################################################################################################################################################
}

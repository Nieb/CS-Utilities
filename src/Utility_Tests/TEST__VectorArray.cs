
namespace UtilityTest;
internal static partial class Program {
    static void Test__VectorArray() {
        CONOUT("\n[Utility.VEC Array]");

        //######################################################################################################################################################
        //######################################################################################################################################################
        {
            //float A;
            //float B = A;          //  error: Use of unassigned local variable 'A'

            //vec3  C;
            //float D = C.x;        //  error: Use of possibly unassigned field 'x'

            vec3[] J = new vec3[8]; //  Arrays are allocated, then all bytes zeroed.
            float K = J[4].x;

            TEST("Array Allocation & Initialization", true
                && J[0].x == 0f
                && J[1].y == 0f
                && J[2].z == 0f
                && J[3].x == 0f
                && K == 0f
            );
        }

        //######################################################################################################################################################
        //######################################################################################################################################################
        {
            mat4 A = new mat4(
                 1f,  2f,  3f,  4f,
                 5f,  6f,  7f,  8f,
                 9f, 10f, 11f, 12f,
                13f, 14f, 15f, 16f
            );

            float[] B = A.ToFloatArray();
            B[15] = 99f;

            TEST("Mat4.ToFloatArray()", true
                &&  A.xx  ==  1f  &&  A.yx  ==  2f &&  A.zx  ==  3f  &&  A.wx  ==  4f
                &&  A.xy  ==  5f  &&  A.yy  ==  6f &&  A.zy  ==  7f  &&  A.wy  ==  8f
                &&  A.xz  ==  9f  &&  A.yz  == 10f &&  A.zz  == 11f  &&  A.wz  == 12f
                &&  A.xw  == 13f  &&  A.yw  == 14f &&  A.zw  == 15f  &&  A.ww  == 16f

                &&  B[ 0] ==  1f  &&  B[ 1] ==  2f &&  B[ 2] ==  3f  &&  B[ 3] ==  4f
                &&  B[ 4] ==  5f  &&  B[ 5] ==  6f &&  B[ 6] ==  7f  &&  B[ 7] ==  8f
                &&  B[ 8] ==  9f  &&  B[ 9] == 10f &&  B[10] == 11f  &&  B[11] == 12f
                &&  B[12] == 13f  &&  B[13] == 14f &&  B[14] == 15f  &&  B[15] == 99f
            );
        }

        //######################################################################################################################################################
        //######################################################################################################################################################
        {
            vec2[] A = new vec2[] {
                ( 0.1f, 1.1f), ( 2.1f, 3.1f), ( 4.1f, 5.1f), ( 6.1f, 7.1f),
                ( 8.1f, 9.1f), (10.1f,11.1f), (12.1f,13.1f), (14.1f,15.1f),
                (16.1f,17.1f), (18.1f,19.1f), (20.1f,21.1f), (22.1f,23.1f),
                (24.1f,25.1f), (26.1f,27.1f), (28.1f,29.1f), (30.1f,31.1f)
            };
            float[] B = A.ToFloatArray();

            bool Result = true;
            for (int i = 0; i < A.Length; ++i) {
                Result = Result && (A[i].x == B[i*2    ])
                                && (A[i].y == B[i*2 + 1]);
            }
            TEST("Vec2[].ToFloatArray()", Result);
        }

        //======================================================================================================================================================
        {
            vec3[] A = new vec3[] {
                ( 0.1f, 1.1f, 2.1f), ( 3.1f, 4.1f, 5.1f), ( 6.1f, 7.1f, 8.1f), ( 9.1f,10.1f,11.1f),
                (12.1f,13.1f,14.1f), (15.1f,16.1f,17.1f), (18.1f,19.1f,20.1f), (21.1f,22.1f,23.1f),
                (24.1f,25.1f,26.1f), (27.1f,28.1f,29.1f), (30.1f,31.1f,32.1f), (33.1f,34.1f,35.1f),
                (36.1f,37.1f,38.1f), (39.1f,40.1f,41.1f), (42.1f,43.1f,44.1f), (45.1f,46.1f,47.1f)
            };
            float[] B = A.ToFloatArray();

            bool Result = true;
            for (int i = 0; i < A.Length; ++i) {
                Result = Result && (A[i].x == B[i*3    ])
                                && (A[i].y == B[i*3 + 1])
                                && (A[i].z == B[i*3 + 2]);
            }
            TEST("Vec3[].ToFloatArray()", Result);
        }

        //------------------------------------------------------------------------------------------------------------------------------------------------------
        /*
        {
            vec3[] A = new vec3[] {
                ( 0.1f, 1.1f, 2.1f), ( 3.1f, 4.1f, 5.1f), ( 6.1f, 7.1f, 8.1f), ( 9.1f,10.1f,11.1f),
                (12.1f,13.1f,14.1f), (15.1f,16.1f,17.1f), (18.1f,19.1f,20.1f), (21.1f,22.1f,23.1f),
                (24.1f,25.1f,26.1f), (27.1f,28.1f,29.1f), (30.1f,31.1f,32.1f), (33.1f,34.1f,35.1f),
                (36.1f,37.1f,38.1f), (39.1f,40.1f,41.1f), (42.1f,43.1f,44.1f), (45.1f,46.1f,47.1f)
            };

            float[] B = System.Runtime.CompilerServices.Unsafe.As<vec3[],float[]>(ref A);
            //
            //      A.Length == 16
            //      B.Length == 16      should be 48...
            //
            CONOUT($"{A.Length}    {B.Length}");

            //bool Result = true;
            //for (int i = 0; i < A.Length; ++i) {
            //    Result = Result && (A[i].x == B[i*3    ])
            //                    && (A[i].y == B[i*3 + 1])
            //                    && (A[i].z == B[i*3 + 2]);
            //}
            //TEST("Unsafe.As<vec3[],float[]>", Result);

            unsafe {
                fixed (vec3* pA = A) {
                    float* pB = (float*)pA;
                    int B_Length = A.Length * 3; //(sizeof(vec3) / sizeof(float));

                    CONOUT($"{A.Length}    {B_Length}");

                    bool Result = true;
                    for (int i = 0; i < A.Length; ++i) {
                        Result = Result && (A[i].x == pB[i*3    ])
                                        && (A[i].y == pB[i*3 + 1])
                                        && (A[i].z == pB[i*3 + 2]);
                    }
                    TEST("Vec3[]  unsafe { Pointer }  Float[]", Result);
                }
            }
        }
        */

        //======================================================================================================================================================
        {
            vec4[] A = new vec4[] {
                ( 0.1f, 1.1f, 2.1f, 3.1f), ( 4.1f, 5.1f, 6.1f, 7.1f), ( 8.1f, 9.1f,10.1f,11.1f), (12.1f,13.1f,14.1f,15.1f),
                (16.1f,17.1f,18.1f,19.1f), (20.1f,21.1f,22.1f,23.1f), (24.1f,25.1f,26.1f,27.1f), (28.1f,29.1f,30.1f,31.1f),
                (32.1f,33.1f,34.1f,35.1f), (36.1f,37.1f,38.1f,39.1f), (40.1f,41.1f,42.1f,43.1f), (44.1f,45.1f,46.1f,47.1f),
                (48.1f,49.1f,50.1f,51.1f), (52.1f,53.1f,54.1f,55.1f), (56.1f,57.1f,58.1f,59.1f), (60.1f,61.1f,62.1f,63.1f)
            };
            float[] B = A.ToFloatArray();

            bool Result = true;
            for (int i = 0; i < A.Length; ++i) {
                Result = Result && (A[i].x == B[i*4    ])
                                && (A[i].y == B[i*4 + 1])
                                && (A[i].z == B[i*4 + 2])
                                && (A[i].w == B[i*4 + 3]);
            }
            TEST("Vec4[].ToFloatArray()", Result);
        }

        //######################################################################################################################################################
        //######################################################################################################################################################
    }
}
